---
title: "WGCNA"
subtitle: Program 11
author: "Francois Collin"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
always_allow_html: true
---


## mRNA Seq - WGCNA

> "_The Weighted Correlation Network Analysis (WGCNA) [11,12] corresponds to a
> data reduction method and unsupervised classification method. It simplifies
> the interpretation of thousands of gene responses to a dozen of synthetic
> groups (or modules) of genes. The net establishes connections between
> genes-genes are connected if their expression is correlated. Genes can be
> more or less intensively connected depending on the value of the correlation
> (the weights). The connectivity between genes is then interpreted into a
> distance, and the distance is used to group genes into modules. This is how a
> high number of genes can be reduced into a small number of clusters whose
> expression is quantified by the Eigengenes (first principal component within
> the module). It relies on the assumption that highly correlated genes within
> a module are involved in common biological processes._" @Niemira2020

Two gene co-expression networks were obtained, 1) the first one based on
baseline samples for NGT and T2D subject samples and
2) the second on training-induced expression variation independently from the
study arm. In detail:

1. baseline samples for NGT and T2D were selected, the same inclusion criteria 
   as in the section "_Differential expression analysis_" were used.
   Gene expression was transformed using variance
   stabilizing transformation. The optimal soft-threshold adjacency matrix
   was graphically determined, then the network was estimated resulting in
   gene modules and corresponding Eigengenes. The `cutreeDynamic` algorithm
   was used for tree pruning of the gene hierarchical clustering dendrogram
   resulting in co-expression modules; correlated modules (r > 0.80) were
   merged. The quantitative clinical parameters were centred to the average and
   scaled-to-variance while factors were decomposed into dummy variables
   so as to study the association between gene modules and clinical traits
   quantified with Pearson's correlation coefficient. 
2. training-induced variation was studied similarly, the approach above was
   applicable here also, using the difference between variance-stabilizing
   transformed expression matrix as input to the procedure.

Note: it is not possible to use the differentially expressed genes as a
starting point. The WGCNA method includes a disclaimer preventing the
use of pre-filtered / selected genes based on DEG analysis result.

The module identification was followed by gene set enrichment analysis. To do
so, the correlation between gene expression (Variance-Stabilized Transformed
values, VST) and the eigengene estimated in every module was used as a 
measure of module membership. Then, for every module, genesets as defined
by the Gene Ontology (GO) project were selected if at least 10 genes belonged
to the module. Then, the GSEA procedure was run while considering
all expressed genes with existing _entrez gene_ id and determining an
enrichment score and associated p.value based on 10000 random permutations.
The result focused specifically on enriched and up-regulated genesets, i.e.
genesets with over representation of genes with higher
correlation with the eigengene within each module.

The analysis was realized with R [v4.2.0, @RCT2022]. Note the
use of the additional packages downloaded from the RStudio package manager
repository (freeze date 2022-05-04, [repos](
https://packagemanager.rstudio.com/all/2022-05-04+Y3JhbiwyOjQ1MjYyMTU7NTVFQjhGODU)):

- `MultiAssayExperiment` for management of multi-omics experiment objects
  [version 1.22.0, @Ramos2017]
- `DESeq2` for differential expression analysis and
  variance stabilizing transformation [version 1.36.0, @Love2014]
- `cowplot` for figure composition [version 1.1.1, @Wilke2020]
- `ggplot2` for graphics [version 3.3.6, @Wickham2016]



```{r, cfg_prog}
cfg_prog <- yaml::read_yaml("_prog.yml")
cfg_prog
```

```{r, settings}
devtools::load_all("src/pkg/dbs.data")
devtools::load_all("src/pkg/latarnia.utils")

knitr::opts_chunk$set(results = cfg_prog$knitr$results)

source("R/ngs.R")
source("R/inches.R")
```

### Materials and Methods

#### Helper functions

```{r}
# Help for data pre-processing
filter_for_depth <- function(mae, assay, depth_threshold) {
  mae[, colSums(mae[[ngs_assay]]) > depth_threshold, ]
}

filter_for_visit <- function(mae, visit) {
  mae[, colData(mae)$avisit == visit, ]
}

filter_for_low_expr <- function(mae, assay, cpm_threshold,
                                frac_cols = cfg_prog$rna$cpm_threshold$fraccol
) {
  # Genes expressed at least cpm_threshold in frac_cols columns
  mae[
    rowSums(cpm(mae[[assay]]) > cpm_threshold) >
      ncol(mae[[assay]]) * frac_cols,
    ,
  ]
}
```

#### Data preparation

```{r, ads}
#| code-fold: show
adsl <- dbs.data::adsl
advs <- dbs.data::advs
adlb <- dbs.data::adlb

#' Subjid and Visit to Sample
#' 
subjvis_to_spl <- function(df) paste0(df$subjid, "v", df$avisitn)

ads <- adlb |>
  rbind(advs) |>
  subset(select = -c(ct, dtype, param, base, basetype, chg, pchg)) |>
  tidyr::pivot_wider(names_from = "paramcd", values_from = "aval") |>
  merge(adsl, y = _, by = "subjid") |>
  (\(df) S4Vectors::DataFrame(df, row.names = subjvis_to_spl(df)))() |>
  subset(select = c(subjid, diabcd, diab, avisitn, avisit, GLU120)) |>
  (\(df) {
    assertthat::assert_that(all(table(subjvis_to_spl(df)) == 1))
    df
  })()

ads
```

```{r, rna}
rna <- list(
  mrna = dbs.data::mrna_raw,
  premirna = dbs.data::premirna_raw,
  mirna = dbs.data::mirna_raw
)

rna[c("premirna", "mirna")] <- lapply(
  X = rna[c("premirna", "mirna")],
  FUN = format_mirna
)

# Rows represent genes
rna <- lapply(X = rna, FUN = function(x) y <- x[rowSums(x) > 0, ])
rna <- lapply(X = rna, as.matrix)
assertthat::assert_that(all(colnames(rna$premirna) == colnames(rna$mirna)))
rna$allmirna <- rbind(rna$premirna, rna$mirna)

library(testthat)
test_that("rna features discriminated in noexpr, expr", {
  lapply(X = rna, FUN = \(x) expect_true(all(rowSums(x) > 0)))
})
```

```{r, mae}
library(MultiAssayExperiment)

#' (Sample-)Map Arrays
#'
#' Use the column names of `x` to deduce the `primary` and `colnames`.
#' This is used to generate the sample mapping between colData and Experiments.
#'
#' @param x (`dataframe`).
#'
#' @note In our case, primary and colnames are equivalent, colnames could
#' be different from primary names when a biological sample has different
#' names in the biological assays (e.g. machine constraint, technical
#' repetitions).
#'
#' @seealso [MultiAssayExperiment::listToMap()]
#' @examples
#' \dontrun{
#'   lapply(rna, map_arrays)
#'   MultiAssayExperiment::listToMap(lapply(rna, map_arrays))
#' }
#'
map_arrays <- function(x) {
  y <- data.frame(colname = colnames(x))
  y$primary <- y$colname
  y
}

besd_mae <- MultiAssayExperiment(
  experiments = ExperimentList(rna),
  colData = ads,
  sampleMap = listToMap(lapply(rna, map_arrays))
)

besd_mae
```

```{r, filter, eval=TRUE}
#' # https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-01-dataInput.pdf
#' # WGCNA: gene in rows, sample in cols

ctrl <- cfg_prog$rna
ngs_assay <- "allmirna"
dta <- besd_mae |>
  (\(mae) mae[ , , ngs_assay])() |>
  filter_for_depth(ngs_assay, ctrl$depth_threshold[[ngs_assay]]) |>
  filter_for_visit("Baseline") |>
  filter_for_low_expr(ngs_assay, ctrl$cpm_threshold[[ngs_assay]]) |>
  (\(mae) {
    mae[[ngs_assay]] <-
      DESeq2::DESeqDataSetFromMatrix(
        countData = mae[[ngs_assay]],
        colData = colData(x = mae),
        design = stats::formula(~ diabcd)
      ) |>
      DESeq2::varianceStabilizingTransformation(blind = FALSE) |>
      SummarizedExperiment::assay()
    mae
  })()

#' WGCNA Expression data.
#'
#' A matrix or data frame in which columns are genes and rows ar samples.
#'
dta_expr <- t(dta[[ngs_assay]])
assert_that(WGCNA::goodSamplesGenes(dta_expr, verbose = 0)$allOK)

dta_traits <- colData(dta)
dta_traits$x <- rownames(dta_traits)
dta_traits$x <- factor(dta_traits$x, levels = labels(dend))
dta_traits <- as.data.frame(dta_traits)
```

### Sample clustering

```{r, sample_clustering, eval=TRUE}
spl_clust <- hclust(dist(dta_expr), method = "complete")

# Clustering Dendrogram of samples based on their Euclidean distance
theme_custom <- function(...) {
    theme_dendro() +
    theme(
      plot.margin = unit(c(0, 0, 0, 0), "null"),
      panel.spacing = unit(c(0, 0, 0, 0), "null")
    ) +
    theme(...)
}

library(ggdendro)
library(ggplot2)
dend <- spl_clust |> as.dendrogram()
lim <- c(0, nobs(dend))
ddata <- ggdendro::dendro_data(dend, type = "rectangle")

p1 <- ggplot(ggdendro::segment(ddata)) +
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
  coord_flip(clip = "off") +
  scale_y_reverse(expand = expansion(0)) +
  scale_x_continuous(
    breaks = seq_len(nobs(dend)),
    labels = ggdendro::label(ddata)$label,
    lim = lim,
    position = "top"
  ) +
  theme_custom(axis.text.y = element_text())


p2 <- ggplot(
  dta_traits,
  aes(
    xmin = 0, xmax = 1,
    ymin = as.numeric(x) - 1/2, ymax = as.numeric(x) + 1/2,
    fill = diabcd
  )
) +
  geom_rect(col = "white") +
  scale_y_continuous(breaks = 1:34) +
  scale_x_continuous(expand = expansion(0)) +
  scale_fill_viridis_d(option = "C", direction = -1, begin = .2, end = .8) +
  coord_cartesian(ylim = lim) +
  theme_custom(legend.position = "top")

p4 <- ggplot(
  dta_traits,
  aes(
    xmin = 0, xmax = 1,
    ymin = as.numeric(x) - 1/2, ymax = as.numeric(x) + 1/2,
    fill = GLU120
  )
) +
  geom_rect(col = "white") +
  scale_y_continuous(breaks = 1:34) +
  scale_x_continuous(expand = expansion(0)) +
  scale_fill_viridis_c() +
  coord_cartesian(ylim = lim) +
  theme_custom(legend.position = "top")

p <- egg::ggarrange(
  p1, p2, p4,
  nrow = 1,
  widths = c(2, 1, 1),
  padding = unit(0, "lines"),
  draw = FALSE
)
p <- clean_slate() |>
  add_title(c(
    "Figure xxx",
    wrap_long_lines(
      "Clustering dendrogram of samples based on their Euclidean distance
      and trait heatmap"
    )
  )) |>
  add_figure(p, height = inches(5)) |>
  add_note(c(
    "Note: VST transformed expression matrix used to estimate distances
    between samples, _complete_ method was used for the hierarchical
    clustering."
  ))
  
```

```{r, eval=cfg_prog$knitr$results!="hide"}
#| fig-width: 11.7
#| fig-height: 8.3
show_slate(p)
```

### Soft threshold determination

```{r}
library(WGCNA)
enableWGCNAThreads()

sft <- pickSoftThreshold(
  dta_expr,
  powerVector = c(c(1:10), seq(from = 12, to=20, by=2)),
  verbose = 0
)

library(ggplot2)
pwr <- cfg_prog$rna$wgcna$baseline$allmirna$adjacency$power
p1 <- ggplot(
  sft$fitIndices,
  aes(
    Power,
    - sign(slope) * SFT.R.sq,
    label = Power,
    shape = Power == pwr
  )
) +
  geom_hline(yintercept = .9, lty = 2) +
  geom_hline(yintercept = c(0, 1), lty = 1) +
  geom_line() +
  geom_point(shape = 3) +
  geom_label(
    data = sft$fitIndices |> subset(Power == 5),
    vjust = 0, nudge_y = .025
  ) +
  geom_segment(
    data = sft$fitIndices |> subset(Power == 5),
    aes(xend = Power, yend = 0)
  ) +
  geom_segment(
    data = sft$fitIndices |> subset(Power == 5),
    aes(xend = -Inf, yend = - sign(slope) * SFT.R.sq)
  ) +
  geom_point(show.legend = FALSE, fill = "white") +
  scale_shape_manual(values = c("TRUE" = 21, "FALSE" = 3)) +
  coord_cartesian(ylim = c(0, 1)) +
  xlab("Soft Threshold (power)") +
  ylab("Scale Free Topology Model Fit") +
  ggtitle("Scale independence") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

p2 <- ggplot(
  sft$fitIndices,
  aes(Power, mean.k., label = Power, shape = Power == pwr)) +
  geom_hline(yintercept = .9) +
  geom_line() +
  geom_segment(
    data = sft$fitIndices |> subset(Power == 5),
    aes(xend = Power, yend = 0)
  ) +
  geom_segment(
    data = sft$fitIndices |> subset(Power == 5),
    aes(xend = -Inf, yend = mean.k.)
  ) +
  geom_label(
    data = sft$fitIndices |> subset(Power == 5),
    vjust = 0, hjust = 0, nudge_y = 1
  ) +
  geom_point(fill = "white", show.legend = FALSE) +
  scale_shape_manual(values = c("TRUE" = 21, "FALSE" = 3)) +
  xlab("Soft Threshold (power)") +
  ylab("Mean connectivity") +
  ggtitle("Mean connectivity") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())

p <- egg::ggarrange(p1, p2, nrow = 1, draw = FALSE)
p <- clean_slate() |>
  add_title(c(
    "Figure xxx",
    "Soft threshold determination"
  )) |>
  add_figure(p, width = inches(6), height = inches(3))

```


```{r, eval=cfg_prog$knitr$results!="hide"}
#| fig-width: 11.7
#| fig-height: 8.3
show_slate(p)
```

### Gene clustering

```{r}
cfg <- cfg_prog$rna$wgcna$baseline$allmirna

# gene dissimilarity
tom_dis <- dta_expr |>
  adjacency(
    type = cfg$adjacency$type,
    power = cfg$adjacency$power,
    corFnc = cfg$adjacency$cor_fn$value
  ) |>
  TOMsimilarity(TOMType = cfg$tom$type) |>
  (\(tom) 1 - tom)()

gene_hc <- tom_dis |>
  as.dist() |>
  hclust(method = "average")

# gene clustering
dyn_mod <- cutreeDynamic(
  gene_hc,
    cutHeight = cfg$cuttree$cut_height,
    minClusterSize = cfg$cuttree$min_cluster_size,
    method = "hybrid",
    distM = tom_dis,
    deepSplit = cfg$cuttree$deep_split,
    pamRespectsDendro = FALSE
  )
dyn_col <- labels2colors(dyn_mod)

# me: module eigengenes (also used to merge dyn_col)
dyn_mge <- dta_expr |> WGCNA::mergeCloseModules(dyn_col)
meig_ls <- dta_expr |> moduleEigengenes(dyn_col)
meig <- meig_ls$eigengenes
meig_dis <- 1 - cor(meig)
meig_hc <- meig_dis |> as.dist() |> hclust(method = "average")
```

```{r, eval=cfg_prog$knitr$results!="hide"}
WGCNA::plotDendroAndColors(
  dendro = gene_hc,
  colors = dyn_mge$color,
  dendroLabels = FALSE,
  hang = -1,
  addGuide = TRUE,
  guideHang = 0.05,
  groupLabels = "",
  cex.rowText = 0.5,
  cex.colorLabels = 0.5,
  cex.dendroLabels = 0.9,
  marAll = c(1, 1, 1, 1),
  axes = FALSE,
  ylab = NULL,
  main = NULL
)
graphics::par(mfrow = c(1, 1))
```

```{r}


#' @describeIn wrap_wgcna improved correlation matrix.
#' @param mat_y,mat_x the matrix used in rows or columns.
#' @param draw (`logical`)
#' @param newpage (`logical`)
#' @import ggplot2
#' @export
#'
gg_eigen <- function(mat_y, mat_x, draw = TRUE, newpage = FALSE) {

  dta <- stats::cor(mat_y, mat_x, use = "pairwise.complete.obs")
  dta <- reshape2::melt(
    dta, varnames = c("eig", "traits"), value.name = "cor"
  )
  dta$cor_pval <- WGCNA::corPvalueStudent(dta$cor, nSamples = nrow(mat_x))

  local_theme <- function(gg) {
    gg + scale_x_continuous(
      expand = c(0, 0.5)
    ) + scale_y_continuous(
      expand = c(0.02, 0)
    ) + theme(
      axis.text.x = element_blank(),
      axis.text.y = element_blank(),
      legend.background = element_rect(
        fill = "transparent", colour = "transparent"
      ),
      panel.background = element_rect(
        fill = "transparent", colour = "transparent"
      ),
      plot.background = element_rect(
        fill = "transparent", colour = "transparent"
      )
    )
  }

  dendro_y   <- stats::hclust(d = stats::as.dist(1 - stats::cor(mat_y)))
  dendro_y   <- stats::as.dendrogram(dendro_y);
  y_neworder <- labels(dendro_y)
  dendro_y   <- ggdendro::ggdendrogram(
    data = dendro_y, rotate = TRUE
  ) + theme(
    plot.margin = unit(c(0,0,0,-0.2), units="lines")
  )
  dendro_y <- local_theme(gg = dendro_y)

  dendro_x <- stats::as.dist(1 - stats::cor(mat_x))
  dendro_x <- stats::hclust(d = stats::dist(x = dendro_x))
  dendro_x <- stats::as.dendrogram(dendro_x)
  x_neworder <- labels(dendro_x)
  dendro_x <- ggdendro::ggdendrogram(
    data = dendro_x, rotate = FALSE
  ) + theme(
    plot.margin = unit(c(0,0,-.8,0), units="lines")
  )
  dendro_x <- local_theme(gg = dendro_x)

  dta$traits <- factor(dta$traits, levels = x_neworder)
  dta$eig <- factor(dta$eig, levels = y_neworder)

  dta$cor_pval_2d <- round(dta$cor_pval, 2)
  # Create heatmap plot
  heatmap.plot <- ggplot(
    data = dta,
    mapping = aes_string(x = "traits", y = "eig")
  ) + geom_tile(
    data = dta, fill = "transparent", col = "gray"
  ) + geom_tile(
    # data = dta[dta$cor_pval < 0.1, ],
    mapping = aes_string(fill = "cor")
  ) + geom_text(
    # data = dta[dta$cor_pval < 0.1, ],
    mapping = aes_string(label = "cor_pval_2d"),
    col = "white", size = 2
  ) + scale_fill_continuous(
    name = "Corr.",
    guide = guide_colourbar(barheight = 10)
  )+ coord_cartesian(
    expand = FALSE
  ) + theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(),
    legend.position = "left",
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.background = element_rect(
      fill = "transparent", colour = "transparent"
    ),
    panel.background = element_rect(
      fill = "transparent", colour = "transparent"
    ),
    plot.background = element_rect(
      fill = "transparent", colour = "transparent"
    ),
    legend.key.width = grid::unit(.3, "cm"),
  )

  a1 <- ggplotGrob(heatmap.plot)
  a2 <- ggplotGrob(dendro_y)
  a <- cbind(a1, a2, size = "max")
  b <- ggplot2::ggplotGrob(dendro_x)
  b <- gtable::gtable_add_cols(
    b,
    widths = a1$widths[1:(length(a1$widths)-length(b$widths))],
    pos = 0
  )
  b <- gtable::gtable_add_cols(b, widths = a2$widths, pos = -1)

  ab <- rbind(b, a, size = "last")
  ab <- rbind(b, a, size = "last", z = c(1,10))
  ab$heights[7] <- unit(3, "lines")
  ab$widths[16] <- unit(3, "lines")

  if (draw) {
    if (newpage) grid::grid.newpage()
    grid::grid.draw(ab)
  }

  list(
    gg = ab,
    data = dta
  )
}

gg_eigen(
  dta_traits |>
    subset(select = c(GLU120, diabcd)) |>
    within(diabcd <- as.numeric(diabcd)),
  meig
)
```


#### Legacy

```{r, eval=FALSE, include=FALSE}
control_wgcna <- function(
  power,
  type = "signed",
  TOMType = "signed",
  corFnc = c("pearson" = "cor", "bicor" = "bicor")[1], 
  deepSplit = 1, # wa 2 for Medium sensitivity
  cutHeight = 0.995, # Default 0.995
  minClusterSize = 20, # min(20, ncol(datExpr)/2 ) 
  verbose = TRUE
  ) {
  as.list(environment())
}
#' WGCNA Wrappers
#' 
#' Set of function for standardised pre/post processing of WGCNA results.
#'
#' @name wrap_wgcna
#'
NULL

#' @describeIn wrap_wgcna sample dendrogram with trait color matrix.
#' @param x (`list`) suitable for `besd_wgcna`.
#' @export
#'
wrap_sample_dendro <- function(x) {
  trait_colors <- WGCNA::numbers2colors(x$traits)
  WGCNA::plotDendroAndColors(
    x$clust_ind, trait_colors,
    groupLabels = names(x$traits)
  )
  graphics::par(mfrow = c(1, 1))
}


#' VST Norm
#'
#' Feature count normalization.
#'
#' @param mae (`MultiAssayExperiment`)
#' @param assay (`character`)
#' @param adam (`list`)
#'
#' @details The VST normalization stems from the differential expression
#' object preparation so as to insure consistency of methods.
#' The call to the adam datasets is necessary as `CHG` data were not included
#' in the MAE (it would be possible to add it there but I wonder what would
#' be the consequences in terms of analysis result of adding theme).
#'
#' @note Initially prepared for WGCNA, it was evidenced it is more generally
#' applied for a recurrent contrast (baseline data and training-induced
#' variations.
#'
#' @return
#' Every item of the list is a set of expression data and clinical
#' parameters (aka traits).
#' Item a: 
#' baseline feature expression and clinical parameter.
#' Item b: 
#' training-induced expression variation profile across
#' all samples (arm blind).
#'
#' @importFrom stats reshape
#' @importFrom SummarizedExperiment assay
#' @export
#'
vst_norm <- function(
  mae,
  adam = list(
    adsl = adsl,
    adlb = adlb,
    advs = advs
    ),
  assay = c("allmirna", "mrna")) { 

  assay <- match.arg(assay)

  # Expressions as in DE: the data preparation stems from the differential
  # expression preparation function.
  data_as_de <- lapply(
    X = setNames(nm = assay),
    mae = mae,
    FUN = function(x, mae) {
      lapply(
        X = c(Training_all = list(
            c(levels(MultiAssayExperiment::colData(mae)$AVISIT), "no-arm")
            )),
        mae = mae,
        assay = x,
        control = control_rna(verbose = TRUE),
        FUN = prepare_de
      )
    }
  )

  # Instead of model fit, get the vst transformed results.
  gc(reset = TRUE)
  get_vst <- function(x, assay) {
    x$vst <- DESeq2::varianceStabilizingTransformation(x$dds, blind = FALSE)
    x$mae[[assay]] <- SummarizedExperiment::assay(x$vst)
    x
  }
  vst <- get_vst(x = data_as_de[[assay]]$Training_all, assay = assay)

  result <- list()

  # First item
  y <- vst$mae
  y <- y[,
    MultiAssayExperiment::colData(y)$AVISIT == "BASELINE" &
      MultiAssayExperiment::colData(y)$ARMCD %in% c("NGT", "T2D"),
    ]
  expr <- t(y[[assay]])
  traits <- MultiAssayExperiment::colData(y)
  traits <- traits[
    !colnames(traits) %in%
      c(
        "SUBJID", "AVISIT", "sample", "AVISITNUM", "USUBJID", "SEX", "ARM",
        grep(pattern = "^.*SC$", x = names(traits), value = TRUE)
      )
    ]
  traits <- data.frame(
    lapply(traits, function(x) as_scaled_numeric(x)),
    row.names = row.names(traits)
  )
  assertthat::assert_that(all(rownames(traits) == rownames(expr)))
  result$a <-  list(
    expr = expr,
    traits = traits
  )

  # Second item
  # Expression From VST.
  assertthat::assert_that(
    all(table(MultiAssayExperiment::colData(vst$mae)$USUBJID) == 2)
  )
  subj <- unique(MultiAssayExperiment::colData(vst$mae)$USUBJID)
  ls_avisit <- MultiAssayExperiment::colData(vst$mae)
  ls_avisit <- as.data.frame(ls_avisit)
  ls_avisit <- split(ls_avisit, f = ls_avisit$AVISIT)
  bl <- rownames(ls_avisit$BASELINE)[match(subj, ls_avisit$BASELINE$USUBJID)]
  m3 <- rownames(ls_avisit$`MONTH 3`)[match(subj, ls_avisit$`MONTH 3`$USUBJID)]
  expr <- vst$mae[[assay]]
  expr <- expr[, m3] - expr[, bl]
  expr <- t(expr)
  rownames(expr) <- gsub(
    pattern = "^(X[0-9]*)v.*$",
    x = rownames(expr),
    replacement = "\\1"
  )

  # Traits CHG.
  # Long-format ADaM, key is UBSUJID x AVISIT.
  # Lab test data are added.
  adsl <- adam$adsl
  adlb <- adam$adlb
  advs <- adam$advs

  anl <- adlb[
    adlb$AVISIT == "MONTH 3" &
      adlb$PARAMCD %in% c(
        "CHOL", "HBA1C", "HDL", "HOMAB", "HOMAIR", "LDL", "MATSUDA", "TRIG"
        ),
      ]
  anl <- stats::reshape(
    data = anl[c("USUBJID", "PARAMCD", "CHG", "PCHG")],
    v.names = c("CHG", "PCHG"),
    timevar = "PARAMCD",
    idvar = "USUBJID",
    direction = "wide"
  )
  adam <- merge(
    x = adsl[c(
      "USUBJID", "SUBJID", "AGE", "SEX", "ARM", "ARMCD",
      "T2DFH", "NTRAIN"
      )],
    y = anl,
    by = "USUBJID"
  )

  # Add the timepoint-defined LB data.
  anl <- adlb[
    adlb$AVISIT == "MONTH 3" &
      adlb$PARAMCD %in% c("GLUC", "INSULIN"),
    ]
  anl$PARAMCD <- paste(# nolint
    anl$PARAMCD, anl$ATPTNUM, sep = "_"
  )
  anl <- stats::reshape(
    data = anl[c("USUBJID", "PARAMCD", "CHG", "PCHG")],
    v.names = c("CHG", "PCHG"),
    timevar = "PARAMCD",
    idvar = "USUBJID",
    direction = "wide"
  )
  adam <- merge(x = adam, y = anl, by = "USUBJID")

  # Vital Sign data are added.
  anl <- stats::reshape(
    data = advs[
      advs$AVISIT == "MONTH 3",
      c("USUBJID", "PARAMCD", "CHG", "PCHG")],
    v.names = c("CHG", "PCHG"),
    timevar = "PARAMCD",
    idvar = "USUBJID",
    direction = "wide"
  )
  adam <- merge(x = adam, y = anl, by = "USUBJID")

  # Clean ADaM names.
  colnames(adam) <- gsub(
    pattern = "^CHG\\.(.*)$",
    x = colnames(adam),
    replacement = "\\1"
  )
  colnames(adam) <- gsub(
    pattern = "^PCHG\\.(.*)$",
    x = colnames(adam),
    replacement = "\\1_PCHG"
  )
  adam$ARMCD <- as.factor(adam$ARMCD)# nolint

  # Traits matrix (numeric).
  assertthat::assert_that(max(table(adam$USUBJID)) == 1)
  traits <- adam[match(subj, adam$USUBJID), ]
  rownames(traits) <- traits$SUBJID
  traits <- traits[
    !colnames(traits) %in% c("SUBJID", "USUBJID", "SEX", "ARM")
    ]
  traits <- data.frame(
    lapply(traits, function(x) as_scaled_numeric(x)),
    row.names = row.names(traits)
  )

  assertthat::assert_that(all(rownames(traits) == rownames(expr)))
  result$b <- list(
    expr = expr,
    traits = traits
  )

  result
}

besd_wgcna <- vst_norm(mae = besd_mae, assay = "mrna")
   
assertthat::assert_that(
  all(
    sapply(
      besd_wgcna,
      function(x) 
        WGCNA::goodSamplesGenes(x$expr, verbose = 0)$allOK
    )
  )
)

#' Add clust_ind to besd_wgcna.
besd_wgcna <- lapply(
  besd_wgcna,
  function(x) {
    x$clust_ind <- hclust(dist(x$expr), method = "complete")
    x
  }
)

besd_wgcna$a$sft_val <- 15
besd_wgcna$b$sft_val <- 6
besd_wgcna  <- lapply(besd_wgcna, wrap_sft)

gc(); gc(reset = TRUE)

#' @describeIn wrap_wgcna add `sft` to `besd_wgcna`;
#'   semi-automatic procedure for sft.
#' @export
#'
wrap_sft <- function(x) {
  sft_power <- unique(c(seq_len(10), seq(10, 30, 2), x$sft_val))
  sft_power <- sft_power[order(sft_power)]
  x$sft <- WGCNA::pickSoftThreshold(
    x$expr,
    powerVector = sft_power,
    verbose = 5
  )
  x
}

#' @describeIn wrap_wgcna plot the soft-threshold determining procedure.
#' @import ggplot2
#' @export
#'
wrap_gg_sft <- function(x) {
  dta <- x$sft$fitIndices
  dta$signed_rsq <- -1 * sign(dta$slope) * dta$SFT.R.sq
  dta <- tidyr::pivot_longer(
    dta[c("Power", "signed_rsq", "mean.k.")],
    cols = c("signed_rsq", "mean.k."),
    names_to = "criteria",
    values_to = "value"
  )
  dta$criteria <- factor(
    dta$criteria,
    levels = c("signed_rsq", "mean.k."),
    labels = c("Scale independence", "Mean connectivity")
  )

  dta_hline <- data.frame(
    criteria = factor(
      levels(dta$criteria)[1],
      levels = levels(dta$criteria)
      ),
    yintercept = 
      dta$value[dta$criteria == levels(dta$criteria)[1] & dta$Power == x$sft_val],
    x = x$sft_val
  )
  ggplot(
    data = dta,
    mapping = aes_string(x = "Power", y = "value", label = "Power")
    ) + geom_hline(
    data = dta_hline,
    mapping = aes_string(yintercept = "yintercept")
    ) + geom_line(
    color = "gray60", lty = 2
    ) + geom_text(
    ) + geom_label(
    data = dta_hline,
    mapping = aes_string(y = "yintercept", x = "x", label = "x")
    ) + facet_wrap(
    criteria ~  ., scales = "free", ncol = 2
  )
}

#' @describeIn wrap_wgcna add `wgcna` to `besd_wgcna`.
#' @param data (`list`)\cr expression profile.
#' @param control (`list`)\cr control as prepared by [control_wgcna()].
#' @importFrom stats cor
#' @export
#'
estimate_wgcna <- function(
  data,
  control = control_wgcna()) {

  if (control$verbose) cat("\n----Adjacency: \n")
  if (control$corFnc == "bicor") bicor <- WGCNA::bicor
  adj <- WGCNA::adjacency(
    datExpr = data,
    power = control$power,
    type = control$type,
    corFnc = control$corFnc
  )

  # Turn adjacency into topological overlap
  if (control$verbose) cat("\n----TOM: \n")
  TOM <-  WGCNA::TOMsimilarity(
    adjMat = adj,
    TOMType = control$TOMType
  )
  dissTOM <- 1 - TOM

  # Call the hierarchical clustering function
  if (control$verbose) cat("\n----hclust: \n")
  dendro <- stats::hclust(stats::as.dist(dissTOM), method = "average")

  # Module identification using dynamic tree cut:
  if (control$verbose) cat("\n----cutreeDynamic: \n")
  # We like large modules, so we set the minimum module size relatively high:
  dynamicMods <- dynamicTreeCut::cutreeDynamic(
    dendro = dendro,
    distM = dissTOM,
    cutHeight = control$cutHeight,
    method = "hybrid",
    deepSplit = control$deepSplit,
    pamRespectsDendro = FALSE,
    minClusterSize = control$minClusterSize
  )

  # Convert numeric lables into colors
  dynamicColors <- WGCNA::labels2colors(dynamicMods)

  # Calculate eigengenes
  MEList <- WGCNA::moduleEigengenes(expr = data, colors = dynamicColors)
  MEs <- MEList$eigengenes

  # Calculate dissimilarity of module eigengenes
  MEDiss <- 1 - cor(MEs);
  # Cluster module eigengenes
  METree <- stats::hclust(stats::as.dist(MEDiss), method = "average")

  # Call an automatic merging function
  merge <- WGCNA::mergeCloseModules(
    data,
    dynamicColors
  )

  color_group <- cbind(
    "Dynamic Tree Cut" = dynamicColors,
    "Merged dynamic" = merge$color
  )
  list(
    dendro = dendro,
    colors = color_group,
    mod_merge = merge,
    MEs = MEs
  )
}

#' @describeIn wrap_wgcna convenient Controls
#' @inheritParams WGCNA::adjacency
#' @inheritParams WGCNA::TOMsimilarity
#' @inheritParams dynamicTreeCut::cutreeDynamic
#' @inheritParams WGCNA::mergeCloseModules
#' @export
#'
control_wgcna <- function(
  power,
  type = "signed",
  TOMType = "signed",
  corFnc = c("pearson" = "cor", "bicor" = "bicor")[1], 
  deepSplit = 1, # wa 2 for Medium sensitivity
  cutHeight = 0.995, # Default 0.995
  minClusterSize = 20, # min(20, ncol(datExpr)/2 ) 
  verbose = TRUE
  ) {
  as.list(environment())
}

besd_wgcna <- lapply(
  X = besd_wgcna,
  FUN = function(x) {
    x$wgcna <- estimate_wgcna(
      data = x$expr,
      control = control_wgcna(power = x$sft_val)
    )
    gc(); gc(reset = TRUE)
    x
  }
)

```

#### Data preparation


## Session Informations

```{r}
sessioninfo::session_info()
```
